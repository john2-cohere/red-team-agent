from pydantic import BaseModel
from typing import List, Dict, ClassVar
import enum
import json

from langchain_core.language_models.chat_models import BaseChatModel
from browser_use.controller.registry.views import ActionModel

from src.utils import dump_llm_messages_pretty

from logging import getLogger

logger = getLogger(__name__)

UNDO_NAVIGATION_TASK_TEMPLATE = """
You have made a wrong move during navigation and you must return to the previous page

Your goal is to return to previous page

Here is what the previous page looks like:

{prev_page_contents}
"""

PLANNING_TASK_TEMPLATE = """
Your task is to fully explore and discover every single page of a web application
To accomplish this, you should try to trigger as many functionalities on the current page as possible

Your goal is to discover the following elements on this page:
1. outgoing_links: links to other pages of the same web application
2. backend_calls: requests made to backend API services

You can find both by interacting with the webpage
Here are some strategies to guide your interaction:
- do not interact with elements that you suspect will trigger a navigation action off of the page
- elements on the page may be hidden, and to interact with them, you may have to perform some action such as expanding a submenu  

If you find that, after clicking on one of the outbound links, you are on *new* page, then immediately go back to your previous page if there are unfinished tasks there  

Here is the plan:
{plan}
"""

class PlanItem(BaseModel):
    plan: str
    completed: bool = False

class Plan(BaseModel):
    plan_items: List[PlanItem]
    model_schema: ClassVar[Dict] = {
        "type": "json_object",
        "schema": {
            "type": "object",
            "required": ["plan_items"],
            "properties": {
                "plan_items": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": ["plan"],
                        "properties": {
                            "plan": {
                                "type": "string",
                                "description": "The plan item description"
                            },
                            "completed": {
                                "type": "boolean",
                                "default": False,
                                "description": "Whether the plan item is completed"
                            }
                        }
                    }
                }
            }
        }
    }

    def __str__(self):
        repr = "\n"
        for plan in self.plan_items:
            # clean [ ] generated by model
            plan.plan = plan.plan.replace("[ ] ", "")

            checkbox = "[ ]" if not plan.completed else "[*]"
            repr += checkbox + "   " + plan.plan + "\n"
        return repr

def generate_plan(llm: BaseChatModel, page_contents: str):
    PLAN_PROMPT = """
Your task is to fully explore and discover every single page of a web application
To accomplish this, you should try to trigger as many functionalities on the page as possible
Your goal is to discover the following elements on this page:
1. outgoing_links: links to other pages of the same web application
2. backend_calls: requests made to backend API services

You can find both by interacting with the webpage
Here are some strategies to guide your interaction:
- do not interact with elements that you suspect will trigger a navigation action off of the page
- elements on the page may be hidden, and to interact with them, you may have to perform some action such as expanding a submenu  

Formulate a plan for interacting with the visible elements on the page. You should output two parts:
1. First your observations about the page
2. Then a step by step plan to interact with the visible elements
    """
    LLM_MSGS = [
    {
        "role": "system",
        "content" : PLAN_PROMPT
    },
    {
        "role": "user",
        "content": page_contents
    }]

    logger.info(f"[PROMPT GENERATE PLAN]:\n{dump_llm_messages_pretty(LLM_MSGS)}")
    
    res = llm.invoke(LLM_MSGS, response_format=Plan.model_schema)
    res = json.loads(res.content)
    return Plan(**res)
        
# TODO: we may want to use message manager for this to get access to all previous actions
def update_plan(llm: BaseChatModel, curr_page_contents: str, prev_page_contents: str, prev_plan: str, last_action: List[ActionModel]):
    UPDATE_PLAN_PROMPT = """
Your task is to fully explore and discover every single page of a web application
To accomplish this, you should try to trigger as many functionalities on the page as possible

Your goal is to discover the following elements on this page:
1. outgoing_links: links to other pages of the same web application
2. backend_calls: requests made to backend API services

You can find both by interacting with the webpage
Here are some strategies to guide your interaction:
- do not interact with elements that you suspect will trigger a navigation action off of the page
- elements on the page may be hidden, and to interact with them, you may have to perform some action such as expanding a submenu  

A plan was created to accomplish the goals above.
Here is the original plan:
{prev_plan}
""".format(prev_plan=prev_plan)
    LLM_MSGS = [
        {
            "role": "system",
            "content": UPDATE_PLAN_PROMPT
        },
        {
            "role": "user",
            "content": """
Your goal is to update the plan if nessescary. This should happen for the following reasons:
1. to check off a completed plan item
2. the page has been dynamically updated, and a modification to the plan is required

Here is the previous page:
{prev_page_contents}

Here is the current page:
{curr_page_contents}

Here are the actions to affect this change:
{last_action}

Return the newly updated plan
""".format(prev_page_contents=prev_page_contents, curr_page_contents=curr_page_contents, last_action=last_action)
        }
    ]

    logger.info(f"[PROMPT UPDATE PLAN]: \n{dump_llm_messages_pretty(LLM_MSGS)}")

    res = llm.invoke(LLM_MSGS, response_format=Plan.model_schema)
    res = json.loads(res.content)
    return Plan(**res)

class NewPageStatus(str, enum.Enum):
	SAME_PAGE = "same_page"
	NEW_PAGE = "new_page"
	UPDATED_PAGE = "updated_page"

def determine_new_page(llm: BaseChatModel, curr_page_contents: str, prev_page_contents: str, curr_url: str, prev_url: str) -> NewPageStatus:
	if curr_page_contents == prev_page_contents:
		return NewPageStatus.SAME_PAGE

	NEW_PAGE_PROMPT = f"""
You are presented with the following views from a browser
Here is the CURR_PAGE:
URL: {curr_url}
{curr_page_contents}

Here is the PREV_PAGE:
URL: {prev_url}
{prev_page_contents}

Given the different views, determine if the CURR_PAGE is a:

1. new_page: different page of the application
2. updated_page: same page of the application, but with an updated view (ie. submenu expansion, pop-up)

Some things to keep in mind:
1. visible elements: the view presented only shows visible elements in the DOM; so elements that are on the same page might not be displayed because is_top_element == False or is_in_viewport == False

Which is why when considering whether the CURR_PAGE is a new_page or updated_page, make your decision by considering both the url and the DOM of the CURR_PAGE
Now make your choices
"""
	LLM_MSGS = [{"role": "user", "content": NEW_PAGE_PROMPT}]
	logger.info(f"[PROMPT NEW PAGE]: \n{dump_llm_messages_pretty(LLM_MSGS)}")

	response_message = llm.invoke(
		LLM_MSGS,
		response_format={
			"type": "json_object",
			"schema": {
				"type": "object",
				"required": ["page_status"],
				"properties": {
					"page_status": {
						"type": "string",
						"enum": [status.value for status in NewPageStatus],
						"description": "The status indicating if this is a new page or updated view"
					}
				}
			}
		}
	)

	if not hasattr(response_message, "content") or not isinstance(response_message.content, str):
		raise ValueError(f"LLM response content is not a string or attribute 'content' is missing. Response: {response_message}")

	try:
		response_data_dict = json.loads(response_message.content)
	except json.JSONDecodeError as e:
		raise ValueError(f"Failed to parse LLM response content as JSON: {response_message.content}") from e

	status = response_data_dict.get("page_status")
	if status not in NewPageStatus._value2member_map_:
		raise ValueError(f"Invalid page_status returned by LLM: {status}")

	return NewPageStatus(status)
