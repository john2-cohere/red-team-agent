from pydantic import BaseModel
from typing import List, Dict, ClassVar
import json

from langchain_core.language_models.chat_models import BaseChatModel
from browser_use.controller.registry.views import ActionModel

from logging import getLogger

logger = getLogger(__name__)

PLANNING_TASK_TEMPLATE = """
Your task is to fully explore and discover every single page of a web application
To accomplish this, you should try to trigger as many functionalities on the current page as possible

Your goal is to discover the following elements on this page:
1. outgoing_links: links to other pages of the same web application
2. backend_calls: requests made to backend API services

You can find both by interacting with the webpage
Here are some strategies to guide your interaction:
- do not interact with elements that you suspect will trigger a navigation action off of the page
- elements on the page may be hidden, and to interact with them, you may have to perform some action such as expanding a submenu  

If you find that, after clicking on one of the outbound links, you are on *new* page, then immediately go back to your previous page if there are unfinished tasks there  

Here is the plan:
{plan}
"""

class PlanItem(BaseModel):
    plan: str
    completed: bool = False

class Plan(BaseModel):
    plan_items: List[PlanItem]
    model_schema: ClassVar[Dict] = {
        "type": "json_object",
        "schema": {
            "type": "object",
            "required": ["plan_items"],
            "properties": {
                "plan_items": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": ["plan"],
                        "properties": {
                            "plan": {
                                "type": "string",
                                "description": "The plan item description"
                            },
                            "completed": {
                                "type": "boolean",
                                "default": False,
                                "description": "Whether the plan item is completed"
                            }
                        }
                    }
                }
            }
        }
    }

    def __str__(self):
        repr = "\n"
        for plan in self.plan_items:
            # clean [ ] generated by model
            plan.plan = plan.plan.replace("[ ] ", "")
            
            checkbox = "[ ]" if not plan.completed else "[*]"
            repr += checkbox + "   " + plan.plan + "\n"
        return repr

     ### PAGE PLANNING ###
    # TODO: current design is to do all prompting about plans out-of-band of browsing agent
    #     def is_new_page(self, prev_url, prev_page_contents, cur_url, curr_page_contents):
    #         NEW_PAGE_PROMPT = """
    # You are tasked with determining if the current DOM state of a browser is the same or different page from the previous one,
    # indicating that the browser has executed a navigational action between the two states. Be careful to differentiate between
    # different webpages and the same webpage with a slightly changed view (ie. popup, menu dropdown, etc.)

    # Here is the current page:
    # {new_url}
    # {new_page}

    # Here is the previous page:
    # {}
    # {old_page}

    # You are tasked with determining if the current DOM state of a browser is the same or different page from the previous one,
    # indicating that the browser has executed a navigational action between the two states. Be careful to differentiate between
    # different webpages and the same webpage with a slightly changed view (ie. popup, menu dropdown, etc.)

    # Now answer, has the page changed?
    # """

def generate_plan(llm: BaseChatModel, page_contents: str):
    PLAN_PROMPT = """
Your task is to fully explore and discover every single page of a web application
To accomplish this, you should try to trigger as many functionalities on the page as possible
Your goal is to discover the following elements on this page:
1. outgoing_links: links to other pages of the same web application
2. backend_calls: requests made to backend API services

You can find both by interacting with the webpage
Here are some strategies to guide your interaction:
- do not interact with elements that you suspect will trigger a navigation action off of the page
- elements on the page may be hidden, and to interact with them, you may have to perform some action such as expanding a submenu  

Formulate a plan for interacting with the visible elements on the page. You should output two parts:
1. First your observations about the page
2. Then a step by step plan to interact with the visible elements
    """
    LLM_MSGS = [
    {
        "role": "system",
        "content" : PLAN_PROMPT
    },
    {
        "role": "user",
        "content": page_contents
    }]
    
    res = llm.invoke(LLM_MSGS, response_format=Plan.model_schema)
    res = json.loads(res.content)
    return Plan(**res)
        
# TODO: we may want to use message manager for this to get access to all previous actions
# may also want to categorize actions by pages
def update_plan(llm: BaseChatModel, curr_page_contents: str, prev_page_contents: str, prev_plan: str, last_action: List[ActionModel]):
    UPDATE_PLAN_PROMPT = """
Your task is to fully explore and discover every single page of a web application
To accomplish this, you should try to trigger as many functionalities on the page as possible

Your goal is to discover the following elements on this page:
1. outgoing_links: links to other pages of the same web application
2. backend_calls: requests made to backend API services

You can find both by interacting with the webpage
Here are some strategies to guide your interaction:
- do not interact with elements that you suspect will trigger a navigation action off of the page
- elements on the page may be hidden, and to interact with them, you may have to perform some action such as expanding a submenu  

A plan was created to accomplish the goals above.
Here is the original plan:
{prev_plan}
""".format(prev_plan=prev_plan)
    LLM_MSGS = [
        {
            "role": "system",
            "content": UPDATE_PLAN_PROMPT
        },
        {
            "role": "user",
            "content": """
Your goal is to update the plan if nessescary. This should happen for the following reasons:
1. to check off a completed plan item
2. the page has been dynamically updated, and a modification to the plan is required

Here is the previous page:
{prev_page_contents}

Here is the current page:
{curr_page_contents}

Here are the actions to affect this change:
{last_action}

Return the newly updated plan
""".format(prev_page_contents=prev_page_contents, curr_page_contents=curr_page_contents, last_action=last_action)
        }
    ]

    logger.info(f"[Update Plan PROMPT]: \n {LLM_MSGS}")

    res = llm.invoke(LLM_MSGS, response_format=Plan.model_schema)
    res = json.loads(res.content)
    return Plan(**res)