from ast import NameConstant
from numpy.char import str_len
from playwright.async_api import Page
from pydantic import BaseModel
from typing import List, Dict, ClassVar, Optional, Tuple
import enum
import json
import difflib

from langchain_core.language_models.chat_models import BaseChatModel
from browser_use.controller.registry.views import ActionModel
from browser_use.agent.views import ActionResult

from src.utils import dump_llm_messages_pretty

from logging import getLogger

logger = getLogger(__name__)

UNDO_NAVIGATION_TASK_TEMPLATE = """
You have successfully visited the new page

Your goal is now to return back to the previous page

Here is the previous page:
URL: {prev_url}
{prev_page_contents}
"""

PLANNING_TASK_TEMPLATE = """
Your task is to fully explore and discover every single page of a web application
To accomplish this, you should try to trigger as many functionalities on the current page as possible

Your goal is to discover the following elements on this page:
1. outgoing_links: links to other pages of the same web application
2. backend_calls: requests made to backend API services

You can find both by interacting with the webpage
Here are some strategies to guide your interaction:
- do not interact with elements that you suspect will trigger a navigation action off of the page
- elements on the page may be hidden, and to interact with them, you may have to perform some action such as expanding a submenu  

If you find that, after clicking on one of the outbound links, you are on *new* page, then immediately go back to your previous page if there are unfinished tasks there  

Here is the plan:
{plan}
"""


class PlanItem(BaseModel):
    plan: str
    completed: bool = False


class Plan(BaseModel):
    plan_items: List[PlanItem]
    model_schema: ClassVar[Dict] = {
        "type": "json_object",
        "schema": {
            "type": "object",
            "required": ["plan_items"],
            "properties": {
                "plan_items": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": ["plan"],
                        "properties": {
                            "plan": {
                                "type": "string",
                                "description": "The plan item description",
                            },
                            "completed": {
                                "type": "boolean",
                                "default": False,
                                "description": "Whether the plan item is completed",
                            },
                        },
                    },
                }
            },
        },
    }

    def __str__(self):
        repr = "\n"
        for plan in self.plan_items:
            # clean [ ] generated by model
            plan.plan = plan.plan.replace("[ ] ", "")

            checkbox = "[ ]" if not plan.completed else "[*]"
            repr += checkbox + "   " + plan.plan + "\n"
        return repr

# TODO: dump the ActionModel schema here as well?
PLAN_PREAMBLE = """
Your task is to fully explore and discover every single page of a web application
To accomplish this, you should try to trigger as many functionalities on the page as possible

Your goal is to discover the following elements on this page:
1. outgoing_links: links to other pages of the same web application
2. backend_calls: requests made to backend API services

You can find both by interacting with the webpage
Here are some strategies to guide your interaction:
- do not interact with elements that you suspect will trigger a navigation action off of the page
- elements on the page may be hidden, and to interact with them, you may have to perform some action such as expanding a submenu

Here are some strategies to help you generate a plan:
- each plan_item should only cover one action
- do not reference element indices in your plant_items
""" 

def generate_plan(llm: BaseChatModel, page_contents: str):
    PLAN_PROMPT = """
Formulate a plan for interacting with the visible elements on the page. You should output two parts:
1. First your observations about the page
2. Then a step by step plan to interact with the visible elements
    """
    PLAN_PROMPT = PLAN_PREAMBLE + PLAN_PROMPT
    LLM_MSGS = [
        {"role": "system", "content": PLAN_PROMPT},
        {"role": "user", "content": page_contents},
    ]

    logger.info(f"[PROMPT GENERATE PLAN]:\n{dump_llm_messages_pretty(LLM_MSGS)}")

    res = llm.invoke(LLM_MSGS, response_format=Plan.model_schema)
    res = json.loads(res.content)
    return Plan(**res)


# TODO: we may want to use message manager for this to get access to all previous actions
def update_plan(
    llm: BaseChatModel,
    curr_page_contents: str,
    prev_page_contents: str,
    prev_plan: str,
    last_action: List[ActionModel],
):
    UPDATE_PLAN_PROMPT = """
A plan was created to accomplish the goals above.
Here is the original plan:
{prev_plan}
""".format(
        prev_plan=prev_plan
    )
    UPDATE_PLAN_PROMPT = PLAN_PREAMBLE + UPDATE_PLAN_PROMPT
    LLM_MSGS = [
        {"role": "system", "content": UPDATE_PLAN_PROMPT},
        {
            "role": "user",
            "content": """
Your goal is to update the plan if nessescary. This should happen for the following reasons:
1. to check off a completed plan item
2. the page has been dynamically updated, and a modification to the plan is required

New items should be added to the beginning of the plan

Here is the previous page:
{prev_page_contents}

Here is the current page:
{curr_page_contents}

Here are the actions to affect this change:
{last_action}

Return the newly updated plan
""".format(
                prev_page_contents=prev_page_contents,
                curr_page_contents=curr_page_contents,
                last_action=last_action,
            ),
        },
    ]

    logger.info(f"[PROMPT UPDATE PLAN]: \n{dump_llm_messages_pretty(LLM_MSGS)}")

    res = llm.invoke(LLM_MSGS, response_format=Plan.model_schema)
    res = json.loads(res.content)
    return Plan(**res)

class NewPageStatus(str, enum.Enum):
    SAME_PAGE = "same_page"
    NEW_PAGE = "new_page"
    UPDATED_PAGE = "updated_page"

class NavigationPage(BaseModel):
    page_type: NewPageStatus
    name: Optional[str] = ""
    model_schema: ClassVar[Dict] = {
        "type": "json_object",
        "schema": {
            "type": "object",
            "required": ["page_type"],
            "properties": {
                "page_type": {
                    "type": "string",
                    "enum": [status.value for status in NewPageStatus],
                    "description": "The type of page transition that occurred"
                },
                "name": {
                    "type": "string",
                    "description": "Optional name for the updated page view"
                }
            }
        }
    }

def determine_new_page(
    llm: BaseChatModel,
    curr_page_contents: str,
    prev_page_contents: str,
    curr_url: str,
    prev_url: str,
    prev_goal: str,
    subpages: List[Tuple[str, str, str]],
) -> NavigationPage:
    if curr_page_contents == prev_page_contents:
        return NewPageStatus.SAME_PAGE

    # Check if this matches any previously seen subpages
    highest_match = 0
    matched_subpage = None
    for url, page_contents, name in subpages:
        if curr_url != url:
            continue 
        matcher = difflib.SequenceMatcher(None, curr_page_contents, page_contents)
        ratio = matcher.ratio()
        if ratio > highest_match:
            highest_match = ratio
            matched_subpage = name

    # If we have a very high match with a previous subpage,
    # this is likely an updated view rather than new page
    if highest_match > 0.9:
        logger.info(f"Found match for {curr_url} in existing subpage {matched_subpage}")
        return NavigationPage(
            page_type=NewPageStatus.UPDATED_PAGE,
            name=matched_subpage
        )

    NEW_PAGE_PROMPT = f"""
You are presented with the following views from a browser
Here is the CURR_PAGE:
URL: {curr_url}
{curr_page_contents}

Here is the PREV_PAGE:
URL: {prev_url}
{prev_page_contents}

Here is the action that was executed to get from the previous goal to here:
{prev_goal}

Given the different views, determine if the CURR_PAGE is a:

1. new_page: different page of the application
2. updated_page: same page of the application, but with an updated view (ie. submenu expansion, pop-up)
- if it is an updated_page, then also return the name of updated_page

Some things to keep in mind:
1. visible elements: the view presented only shows visible elements in the DOM; so elements that are on the same page might not be displayed because is_top_element == False or is_in_viewport == False

Which is why when considering whether the CURR_PAGE is a new_page or updated_page, make your decision by considering both the url and the DOM of the CURR_PAGE
Now make your choices
"""
    LLM_MSGS = [{"role": "user", "content": NEW_PAGE_PROMPT}]

    res = llm.invoke(
        LLM_MSGS,
        response_format=NavigationPage.model_schema
    )
    res = json.loads(res.content)
    page = NavigationPage(**res)

    logger.info(f"[PROMPT NEW PAGE]: \n{dump_llm_messages_pretty(LLM_MSGS)}\nPAGE_STATUS: {page.page_type}")

    return page


# # TODO: technically we can use evaluation here if it was consistent instead of using
# # comparing the prev and curr page contents
# def check_plan(
#     plan: Plan, 
#     prev_page_contents: str,
#     curr_page_contents: str, 
#     prev_goal: str
# ):
#     CHECK_PLAN = """
# You are a web agent that is tasked with accomplishing some browser navigation goals

# Here is the plan you are following:
# {plan}

# Here is the previous page:
# {prev_page_contents}

# Here is the current page:
# {curr_page_contents}

# Here is the action that you previously executed:
# {prev_goal}

# Determine 

# """