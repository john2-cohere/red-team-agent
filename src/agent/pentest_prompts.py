import pdb
from typing import List, Optional

from browser_use.agent.prompts import SystemPrompt, AgentMessagePrompt
from browser_use.agent.views import ActionResult, ActionModel
from browser_use.browser.views import BrowserStateSummary
from browser_use.http import HTTPMessage

from langchain_core.messages import HumanMessage, SystemMessage
from dataclasses import dataclass, field
from datetime import datetime
import importlib

from .custom_views import CustomAgentStepInfo


@dataclass
class EmptyMsg:
    role: str = "user"
    content: List[str] = field(default_factory=lambda: [""])

VULN_ANALYSIS = """
AGENT_STATE:
{observations}

You are a seasoned vulnerability hunter controlling an autonomous AI web agent to
perform initial reconnaissance on a website as part of their bug bounty program. Above
is some data that represents the current state of the browser

Analyze the current agent state, including prior action history as well as the HTTP 
requests/responses received from executing the last action, and give your observations
on where potential vulnerabilities exist. Your analysis will be used to guide the next
step of the browser vulnerability hunting agent. Include snippets of the agent state that informs
your analysis

Now give your analysis
"""

async def get_agent_prompt(
        state: BrowserStateSummary,
        actions: Optional[List[ActionModel]],
        results: Optional[List[ActionResult]],
        step_info: Optional[CustomAgentStepInfo],
        messages: List[HTTPMessage],
        use_vision: bool = False,
        include_attributes: list[str] = [],
):
    if step_info.step_number == 1:
        return HumanMessage(content=[""])

    if step_info:
        step_info_description = f'Current step: {step_info.step_number}/{step_info.max_steps}\n'
    else:
        step_info_description = ''

    time_str = datetime.now().strftime("%Y-%m-%d %H:%M")
    step_info_description += f"Current date and time: {time_str}"

    elements_text = state.element_tree.clickable_elements_to_string(include_attributes=include_attributes)

    has_content_above = (state.pixels_above or 0) > 0
    has_content_below = (state.pixels_below or 0) > 0

    if elements_text != '':
        if has_content_above:
            elements_text = (
                f'... {state.pixels_above} pixels above - scroll or extract content to see more ...\n{elements_text}'
            )
        else:
            elements_text = f'[Start of page]\n{elements_text}'
        if has_content_below:
            elements_text = (
                f'{elements_text}\n... {state.pixels_below} pixels below - scroll or extract content to see more ...'
            )
        else:
            elements_text = f'{elements_text}\n[End of page]'
    else:
        elements_text = 'empty page'

    messages_str = "\n".join([await msg.to_str() for msg in messages])

    state_description = f"""
{step_info_description}
1. Task: {step_info.task}. 
2. Hints(Optional): 
{step_info.add_infos}
3. Memory: 
{step_info.memory}
4. Current url: {state.url}
5. Available tabs:
{state.tabs}
6. Interactive elements:
{elements_text}
7. HTTP Messages:
{messages_str}
    """
    
    if actions and results:
        state_description += "\n **Previous Actions** \n"
        state_description += f'Previous step: {step_info.step_number - 1}/{step_info.max_steps} \n'
        for i, result in enumerate(results):
            action = actions[i]
            state_description += f"Previous action {i + 1}/{len(results)}: {action.model_dump_json(exclude_unset=True)}\n"
            if result.error:
                # only use last 300 characters of error
                error = result.error.split('\n')[-1]
                state_description += (
                    f"Error of previous action {i + 1}/{len(results)}: ...{error}\n"
                )
            if result.include_in_memory:
                if result.extracted_content:
                    state_description += f"Result of previous action {i + 1}/{len(results)}: {result.extracted_content}\n"

    if state.screenshot and use_vision == True:
        # Format message for vision model
        return HumanMessage(
            content=[
                {'type': 'text', 'text': state_description},
                {
                    'type': 'image_url',
                    'image_url': {'url': f'data:image/png;base64,{state.screenshot}'},
                },
            ]
        )

    return HumanMessage(content=state_description)
