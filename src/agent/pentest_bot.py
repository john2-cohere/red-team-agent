import enum
import json
from typing import List, Dict, Optional
from pydantic import BaseModel, Field

from langchain_core.language_models.chat_models import BaseChatModel
from browser_use.controller.registry.views import ActionModel
from browser_use.agent.views import ActionResult

from src.utils import dump_llm_messages_pretty, retry_sync, EarlyShutdown

from pentest_bot.agent.logger import AgentLogLevels
from logging import getLogger

full_logger = getLogger(AgentLogLevels.FULL_REQUESTS)
agent_logger = getLogger(AgentLogLevels.AGENT)

class PentestStepResult(BaseModel):
    """Result of a single pentest step."""
    action: ActionModel
    result: ActionResult
    next_step: Optional[str] = None

    model_schema: ClassVar[Dict] = {
        "type": "object",
        "required": ["action", "result"],
        "properties": {
            "action": {
                "type": "object",
                "description": "The action to take"
            },
            "result": {
                "type": "object",
                "description": "The expected result of the action"
            },
            "next_step": {
                "type": "string",
                "description": "Optional description of the next step"
            }
        }
    }

PENTEST_STEP_TEMPLATE = """
You are a penetration testing agent tasked with finding security vulnerabilities in a web application.

Your goal is to:
1. Identify potential security vulnerabilities
2. Test for common web application vulnerabilities
3. Document your findings

Here is the current state:
{current_state}

Here is the previous action and result:
{previous_action}

Based on this information, determine the next penetration testing step to take.
"""

@retry_sync(max_retries=3, exceptions=(Exception, ValueError), exc_class=EarlyShutdown)
def pentest_step(
    llm: BaseChatModel,
    current_state: str,
    previous_action: Optional[Dict] = None
) -> PentestStepResult:
    """
    Execute a single penetration testing step using the LLM.
    
    Args:
        llm: The language model to use
        current_state: Description of the current application state
        previous_action: Optional previous action and result
        
    Returns:
        PentestStepResult containing the next action to take
    """
    messages = [
        {"role": "system", "content": PENTEST_STEP_TEMPLATE},
        {"role": "user", "content": f"Current state: {current_state}\nPrevious action: {previous_action or 'None'}"}
    ]

    full_logger.info(f"[PROMPT PENTEST STEP]:\n{dump_llm_messages_pretty(messages)}")

    res = llm.invoke(messages, response_format=PentestStepResult.model_schema)
    result = PentestStepResult(**json.loads(res.content))

    agent_logger.info(f"[PENTEST STEP] Action: {result.action}")
    agent_logger.info(f"[PENTEST STEP] Expected result: {result.result}")
    if result.next_step:
        agent_logger.info(f"[PENTEST STEP] Next step: {result.next_step}")

    return result 